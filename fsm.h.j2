{% include "license.j2" %}
{% set FSM_PREFIX = PREFIX.upper() %}
{% set fsm_prefix = FSM_PREFIX.lower() %}
#ifndef __{{fsm_prefix}}_fsm_h__
#define __{{fsm_prefix}}_fsm_h__

#include <sys/eventfd.h>
#include <stddef.h>
#include <stdlib.h>

#include "fsm.h"

#define {{FSM_PREFIX}}_FSM_ST_INITIAL_STATE {{FSM_PREFIX}}_FSM_ST_{{states[0].upper()}}

enum {{fsm_prefix}}_fsm_states {
	{{FSM_PREFIX}}_FSM_ST_NULL,

{% for state in states %}
	{{FSM_PREFIX}}_FSM_ST_{{state.upper()}},
{% endfor %}

	{{FSM_PREFIX}}_FSM_ST_NUMBER_OF_STATES
};


{% for state in states %}
extern const struct fsm_state {{fsm_prefix}}_fsm_state_{{state.lower()}};
{% endfor %}

enum {{fsm_prefix}}_fsm_event_codes {
	{{FSM_PREFIX}}_FSM_EV_NULL,

{% for event in events %}
	{{FSM_PREFIX}}_FSM_EV_{{event.Name.upper()}},
{% endfor %}

	{{FSM_PREFIX}}_FSM_EV_NUMBER_OF_EVENTS
};

static inline const struct fsm_event *{{fsm_prefix}}_fsm_init(struct fsm *fsm, void *data)
{
	// printf("Initializing {{FSM_PREFIX}}\n\n");
	static const struct fsm_event {{fsm_prefix}}_fsm_events[] = {
	{% for event in events %}
		[{{FSM_PREFIX}}_FSM_EV_{{event.Name.upper()}}] = {
			.code = {{FSM_PREFIX}}_FSM_EV_{{event.Name.upper()}},
			.name = "{{event.Name}}",
			.description = "{{event.Description}}",
		},
	{% endfor %}
	};

	static const struct fsm_state *{{fsm_prefix}}_fsm_states[] = {
		NULL,

	{% for state in states %}
		&{{fsm_prefix}}_fsm_state_{{state.lower()}},
	{% endfor %}

		NULL,
	};

	static const enum {{fsm_prefix}}_fsm_states {{fsm_prefix}}_fsm_transition[{{FSM_PREFIX}}_FSM_ST_NUMBER_OF_STATES][{{FSM_PREFIX}}_FSM_EV_NUMBER_OF_EVENTS] = {
	{% for state_name, state in transitions.items() %}
		[{{FSM_PREFIX}}_FSM_ST_{{state_name.upper()}}] = {
		{% for st in state %}
			[{{FSM_PREFIX}}_FSM_EV_{{st.Event.upper()}}] = {{FSM_PREFIX}}_FSM_ST_{{st.NewState.upper()}},
		{% endfor %}
		},
	{% endfor %}
	};

	fsm->name = "{{FSM_PREFIX}}";
	fsm->n_states = {{FSM_PREFIX}}_FSM_ST_NUMBER_OF_STATES;
	fsm->n_events = {{FSM_PREFIX}}_FSM_EV_NUMBER_OF_EVENTS;
	fsm->events = (const struct fsm_event *){{fsm_prefix}}_fsm_events;
	fsm->states = (const struct fsm_state **){{fsm_prefix}}_fsm_states;
	fsm->state = (const struct fsm_state *)fsm->states[{{FSM_PREFIX}}_FSM_ST_INITIAL_STATE];
	fsm->transitions = (const enum fsm_states ***){{fsm_prefix}}_fsm_transition;
	fsm->data = data;
	fsm->state_changed_fd = eventfd(0, EFD_CLOEXEC);
	fsm->fifo_added_fd = eventfd(0, EFD_CLOEXEC | EFD_SEMAPHORE | EFD_NONBLOCK);

	STAILQ_INIT(&fsm->fifo);
	pthread_mutex_init(&fsm->fifo_mutex, NULL);

	return fsm_enter(fsm);
}

static inline const struct fsm_event *{{fsm_prefix}}_fsm_event(struct fsm *fsm, enum {{fsm_prefix}}_fsm_event_codes event)
{
	return (const struct fsm_event *)&(fsm->events[event]);
}

static inline struct fsm_event *{{fsm_prefix}}_fsm_event_allocated(struct fsm *fsm, enum {{fsm_prefix}}_fsm_event_codes event, void *user_data, free_data_cb free_data_cb)
{
	struct fsm_event *ev = calloc(1, sizeof(*ev));
	if (!ev)
		return NULL;

	*ev = *{{fsm_prefix}}_fsm_event(fsm, event);
	ev->data = user_data;
	ev->free_data_cb = free_data_cb;
	ev->is_allocated = 1;

	return ev;
}

#endif /* __{{fsm_prefix}}_fsm_h__ */
